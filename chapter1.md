---
  title: "Теория вероятностей и R"
  description: "В вводной главе курса Вы вспомните основы теории вероятностей и рассмотрите реализацию основных функций в R. В первой части главы Вы произведёте краткий обзор дискретных распределений, а во второй - непрерывных, а также рассмотрите основные характеристики случайных величин и их зависимости."
  v2: true

---
## Будет ли сегодня дождь?

```yaml
type: PureMultipleChoiceExercise

xp: 50
skills: 1
key: 4ff2227cf9



```

Известно, что каждый день дождь может либо идти, либо не идти. Каждое утро исследователь Геннадий включает специальный прибор, который выводит "1", если дождь в этот день будет, и "0", если дождя не будет. Выберите верное утверждение о работе прибора.


`@hint`
Случаная величина может принимать некоторые значения с определенной вероятностью. Реализация случайной величины в данный момент времени – константа.



`@possible_answers`
- [Значение прибора до его включения – случайная величина.]
- Значение прибора до его включения – константа.
- Геннадий увидел, что прибор показывает "1". Значение прибора – случайная величина. 
- В прошлый четверг дождя не было, и утром прибор показал "0". Показанное значение прибора – случайная величина.


`@feedback`
- Да! До включения прибора, Геннадий может только догадываться, какое значение он покажет, что означает, что это значение случайно!
- Нет! До включения прибора Геннадий не знает, какое именно значение он покажет.
- Нет! Геннадий уже увидел значение прибора, а значит, точно знает, каково оно. Случайность в данном случае отсутствует.
- Нет! Вне зависимости от времени давности, Геннадий уже увидел значение прибора, а значит, точно знает, каково оно. Случайность в данном случае отсутствует.


---
## В ожидании непогоды

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: 06813252d3



```

Как вы поняли, значение прибора до включения – случайная величина, имеющая распределение Бернулли:

![](https://dl.dropboxusercontent.com/s/ocxkserxtg21gax/1_1.png?dl=0 =345x50)

В этом задании вам предстоит найти математическое ожидание значения прибора двумя способами:
* Непосредственно по математической формуле. Помните, что помимо прочего, R – очень удобный калькулятор;
* Используя команду `sum(x*p)`;

– а затем использовать полученное значение для нахождения дисперсии таким же образом.
Пусть Геннадий знает, что прибор выводит "1" с вероятностью 0.25.

`@instructions`
* Напоминаем, что формула для расчёта математического ожидания – это:
 $E(X) = \sum x$

  Эта формула уже внесена в код справа. Заполните её необходимыми числами.

* Теперь попробуем автоматизировать вычисления. Заполните вектор значений `x` случайной величины X, а также вектор вероятностей `p`. Рассчитайте математическое ожидание и сохраните его в переменную `mu`. Выведите `mu` и убедитесь, что результаты совпадают.

* Попробуем использовать полученное `mu` для нахождения диспресии. Напоминаем формулу:
$$Var(X) = E(X - E(X))^2$$

  Дополните код справа и сохраните полученное значение в переменную `variance`. Выведите её.

`@hint`
Внесите в формулу вероятность "успеха". Для нахождения математического ожидания используйте вектор `x = c(0, 1)`. Для нахождения диспресии используйте команду `sum()`.


`@sample_code`
```{r}
# Заполните формулу необходимыми числами 
0 * (1 - ___) + 1 * ___

# Вектор значений x и вероятностей p
x <- c(___, ___)
p <- c(___, ___)

# Математическое ожидание
mu <- sum(___)
mu

# Дисперсия
variance <- ___((x-___)^2*p)
___
```
`@solution`
```{r}
# Заполните формулу необходимыми числами 
0 * (1 - 0.25) + 1 * 0.25

# Вектор значений x и вероятностей p
x <- c(0, 1)
p <- c(0.75, 0.25)

# Математическое ожидание
mu <- sum(x*p)
mu

# Дисперсия
variance <- sum((x-mu)^2*p)
variance
```
`@sct`
```{r}
ex() %>% check_output("0.25", missing_msg = "Проверьте, правильно ли Вы заполнили формулу математического ожидания.")
ex() %>% check_object("x") %>% check_equal(incorrect_msg = "Проверьте правильность заполнения вектора `x`.")
ex() %>% check_object("p") %>% check_equal(incorrect_msg = "Проверьте правильность заполнения вектора `p`.")
ex() %>% check_object("mu") %>% check_equal(incorrect_msg = "Проверьте правильнось переменной `mu`.")
ex() %>% check_object("variance") %>% check_equal()
ex() %>% check_output("0.1875", missing_msg = "Проверьте, вывели ли Вы полученное значение дисперсии.")
success_msg("Здорово! Как Вы видите, R очень удобно использовать в качестве продвинутого калькулятора. Но он способен на гораздо большее!")
```





---
## Бутерброд с маслом

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: d9a2b6ac19



```

Отложив прибор в сторону, исследователь Геннадий проводит свой утренний эксперимент: три раза роняет бутерброд с маслом, после чего записывает в специальную тетрадь результаты: на какую сторону упал бутерброд. Геннадий знает, что вероятность «приземления» на каждую сторону равна 0.5, и что каждое падение происходит независимо от других. В этом задании вам предстоит проанализировать один из таких экспериментов.

Обозначим за $X$ число падений на сторону с маслом. Как вы уже догадались, каждое падение можно представить как испытание Бернулли, а значит $X$ ~ $Bin(3, 0.5)$. Закон распределения выглядит следующим образом:

![](https://dl.dropboxusercontent.com/s/srykcpnabflq16a/1_2.png?dl=0)

`@instructions`
* Пришло время расширить ваши вычислительные возможности. Рассчитайте вероятность $P(X=1)$, используя формулу, приведённую в таблице, и сохраните результат в переменную `p_1`. Биномиальный коэффициент $C_{n}^k$ можно найти при помощи команды `choose(n, k)`.

* Попробуем автоматизировать и это. Команда `dbinom(k, n, p)` вернёт вероятность того, что случайная величина, имеющая биномиальное распределение для `n` опытов Бернулли, в каждом из которых вероятность "успеха" составляет `p`, примет значение `k`. Используя эту команду, вычислите вероятность $P(X=2)$ и сохраните результат в `p_2`.

* Посмотрим, как связаны распределение Бернулли и Биномиальное распределение. Вычислите математическое ожидание одного падения. Сохраните его в переменную `mu_single`. Выведите `mu_single` и убедитесь, что она равна $p$.

* Вычислите математическое ожидание всех результатов эксперимента и сохраните полученное значение в переменную `mu_all`. Выведите `mu_all` и убедитесь, что она равна $np$.

`@hint`
И `p1`, и `p2` оказываются равными 0.375. В `x_single` следует внести числа 0 и 1, а в `p_single`: 0.5 и 0.5.


`@sample_code`
```{r}
# Вероятность P(X=1)
p_1 <- choose(3, ___)*___*0.5^___

# Вероятность P(X=2)
p_2 <- ___(___, 3, ___)

# Математическое ожидание одного падения
x_single <- c(___, ___)
p_single <- c(___, ___)
mu_single <- sum(___ * ___)
___

# Математическое ожидание всех падений
x_all <- c(___, ___, ___, 3)
p_all <- c(___, p_1, p_2, ___)
mu_all <- ___(x_all * ___)
mu_all
```
`@solution`
```{r}
# Вероятность P(X=1)
p_1 <- choose(3, 1)*0.5*(0.5^2)

# Вероятность P(X=2)
p_2 <- dbinom(2, 3, 0.5)

# Математическое ожидание одного падения
x_single <- c(0, 1)
p_single <- c(0.5, 0.5)
mu_single <- sum(x_single * p_single)
mu_single

# Математическое ожидание всех падений
x_all <- c(0, 1, 2, 3)
p_all <- c(0.125, p_1, p_2, 0.125)
mu_all <- sum(x_all*p_all)
mu_all
```
`@sct`
```{r}
ex() %>% check_object("p_1") %>% check_equal()
ex() %>% check_object("p_2") %>% check_equal()
ex() %>% check_object("x_single") %>% check_equal()
ex() %>% check_object("p_single") %>% check_equal()
ex() %>% check_object("mu_single") %>% check_equal()
ex() %>% check_output("0.5", missing_msg = "Проверьте, вывели ли Вы значение `mu_single`.")
ex() %>% check_object("x_all") %>% check_equal()
ex() %>% check_object("p_all") %>% check_equal()
ex() %>% check_object("mu_all") %>% check_equal()
ex() %>% check_output("1.5", missing_msg = "Проверьте, вывели ли Вы значение `mu_all`.")
success_msg("Классно! А теперь к следующему заданию!")
```





---
## А что  с дисперсией?

```yaml
type: MultipleChoiceExercise
lang: r
xp: 50
skills: 1
key: 78a750d13c



```

В предыдущем задании вы убедились, что математическое ожидание Биномиального распределения – это математическое ожидание распределения Бернулли, взятое $n$ раз. Верно ли то же самое для дисперсии? Переменные `x_single`, `p_single`, `x_all` и `p_all` из предыдущего задания доступны вам (попробуйте вывести их, введя их названия в консоль). 

Рассчитайте дисперсию результата одного падения, дисперсию всех результатов эксперимента, а также стандартное отклонение результатов всех падений, используя консоль. Вам может пригодиться функция `sqrt()`. Выберите верный ответ.

`@instructions`
- `var_single` = 3, `var_all` = 16, `sd_all` = 4.
- `var_single` = 0.25, `var_all` = 0.75, `sd_all` = 0.87.
- `var_single` = 0.5, `var_all` = 1.5, `sd_all` = 1.22.
- `var_single` = 0.25, `var_all` = 0.64, `sd_all` = 0.8.

`@hint`
Дисперсию можно рассчитать как `variance <- sum((x-mu)^2*p)`. Стандартное отклонение равно `sqrt(variance)`.

`@pre_exercise_code`
```{r}
x_single <- c(0, 1)
p_single <- c(0.5, 0.5)

x_all <- c(0, 1, 2, 3)
p_all <- c(0.125, 0.375, 0.375, 0.125)
```


`@sct`
```{r}
msg1 = "Это слишком большие значения!"
msg2 = "Превосходно! Как вы заметили, Биномиальное распределение естественно происходит из распределения Бернулли. В следующем задании Вы сможете увидеть это."
msg3 = "Вы верно поняли принцип, однако `var_single` рассчитана неправильно."
msg4 = "Проверьте правильность вычисления `var_all`."
test_mc(2, feedback_msgs = c(msg1, msg2, msg3, msg4))
```





---
## Наглядно продемонстрируем!

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: 758425b265



```

Распределение бутербродов, упавших маслом вниз, полученное вами в предыдущих заданиях, представлено здесь:

![](https://dl.dropboxusercontent.com/s/nbcziq9rafnoz82/1_3.png?dl=0)

`@instructions`
* Представьте закон распределения в виде векторов `x` и `p`.
* Для завершения обучения мастерству автоматизации расчётов с помощью R, найдите второй начальный и первый центральный моменты и сохраните полученные значения в переменные `second_raw` и `first_central` соответственно. Напоминаем, что
$$E(X^k)$$
$$E(X-E(X))^k$$
  \- k-ые начальный и центральный моменты.
* Попробуем построить функцию нашего распределения. Для этого будем использовать пакет `ggplot2`, который позволяет быстро строить красивые графики (подробнее вы можете прочитать [здесь](https://www.rdocumentation.org/packages/ggplot2/versions/2.2.1)). Мы уже загрузили этот пакет, а также создали функцию, которая построит наше распределение. Сейчас вам не нужно понимать, как именно она работает (об этом вы узнаете в других курсах). Заполните её элементы `size` и `prob` числом испытаний эксперимента и вероятностью успеха одного испытания соответственно.

* Модифицируйте параметр `size`, чтобы построить функцию распределения Бернулли. Помните, `size` – число испытаний, а не значений, которые принимает случайная величина.

`@hint`
Второй начальный момент можно рассчитать с помощью команды `sum(x^2*p)`. Для построения распределения Бернулли используйте параметр `size = 1`.

`@pre_exercise_code`
```{r}
library(ggplot2)
```
`@sample_code`
```{r}
# Закон распределения
x <- ___
p <- ___

# Второй начальный и первый центральный моменты
second_raw <- ___
mu <- ___
first_central <- ___

# Функция биномиального распределения
ggplot(data.frame(x = c(-5, 5)), aes(x)) + 
stat_function(fun = pbinom, args = list(size = ___, prob = ___), geom = 'step') + 
ylab("F(x)") +
ggtitle("Binomial Distribution") +
theme(plot.title = element_text(hjust = 0.5))

# Функция распределения Бернулли
ggplot(data.frame(x = c(-5, 5)), aes(x)) + 
stat_function(fun = pbinom, args = list(size = ___, prob = 0.5), geom = 'step') +
ylab("F(x)") +
ggtitle("Bernoulli Distribution") +
theme(plot.title = element_text(hjust = 0.5))
```
`@solution`
```{r}
# Закон распределения
x <- c(0, 1, 2, 3)
p <- c(0.125, 0.375, 0.375, 0.125)

# Второй начальный и первый центральный моменты
second_raw <- sum(x^2*p)
mu <- sum(x*p)
first_central <- sum((x-mu)*p)

# Функция биномиального распределения
ggplot(data.frame(x = c(-5, 5)), aes(x)) + 
stat_function(fun = pbinom, args = list(size = 3, prob = 0.5), geom = 'step') + 
ylab("F(x)") +
ggtitle("Binomial Distribution") +
theme(plot.title = element_text(hjust = 0.5))

# Функция распределения Бернулли
ggplot(data.frame(x = c(-5, 5)), aes(x)) + 
stat_function(fun = pbinom, args = list(size = 1, prob = 0.5), geom = 'step') +
ylab("F(x)") +
ggtitle("Bernoulli Distribution") +
theme(plot.title = element_text(hjust = 0.5))
```
`@sct`
```{r}
ex() %>% check_object("x") %>% check_equal()
ex() %>% check_object("p") %>% check_equal()
ex() %>% check_object("second_raw") %>% check_equal()
ex() %>% check_object("mu") %>% check_equal()
ex() %>% check_object("first_central") %>% check_equal()
ex() %>% {
  check_function(., "ggplot") %>% check_arg("data") %>% check_equal()
  check_function(., "aes") %>% {
    check_arg(., "x") %>% check_equal(eval = FALSE) 
  }
   check_function(., "stat_function") %>% {
    check_arg(., "args") %>% check_equal(eval = FALSE)
  }
}
ex() %>% {
  check_function(., "ggplot") %>% check_arg("data") %>% check_equal()
  check_function(., "aes") %>% {
    check_arg(., "x") %>% check_equal(eval = FALSE) 
  }
  check_function(., "stat_function") %>% {
    check_arg(., "args") %>% check_equal(eval = FALSE)
  }
}
success_msg("Чудесно! Посмотрите на графики: распределение Бернулли – это одна ступень Биномиального распределения! А как будет выглядеть график при очень большом числе ступеней? Об этом вы узнаете в следующем видео!")
```





---
## Функции плотности нормального распределения

```yaml
type: PureMultipleChoiceExercise

xp: 50

key: 7f571b03f8



```

![](https://dl.dropboxusercontent.com/s/p26cqr3gzacl5q8/2_1.png?dl=0)

Перед вами графики функций плотности нормального распределения с различными значениями математического ожидания и дисперсии. Подберите для графиков 1 (красный), 2 (зеленый) и 3 (синий) верные значения характеристик.


`@hint`
Обратите внимание на значения, в которых функции плотности достигают максимума, а также на то, все ли значения дисперсии допустимы.





`@possible_answers`
- 1) E(X) = 1, Var(X) = 0.2; 2)  E(X) = 1, Var(X) = 1; 3)  E(X) = 3, Var(X) = 5.
- [1)  E(X) = 0, Var(X) = 0.2; 2)  E(X) = 0, Var(X) = 5; 3)  E(X) = 2, Var(X) = 0.5.]
- 1)  E(X) = 0, Var(X) = 5; 2)  E(X) = 0, Var(X) = 0.2; 3)  E(X) = 2, Var(X) = 0.5.
- 1)  E(X) = 1, Var(X) = -0.2; 2)  E(X) = 1, Var(X) = -5; 3)  E(X) = 2, Var(X) = -1.

`@feedbacks`
- Попробуйте сравнить разброс значений случайной величины, соответствующий 2 и 3 графикам функций плотности, а также обратите внимание на значение математических ожиданий.
- Хорошая работа! Вы научились определять значения основных характеристик по виду функции плотности!
- Попробуйте сравнить разброс значений случайной величины, соответствующий 1 и 2 графикам функций плотности.
- Обратите внимание на допустимые значения дисперсии.




---
## Хи-квадрат

```yaml
type: NormalExercise

xp: 100

key: 2089d6638f



```

Исследователь Геннадий переходит к работе с непрерывными распределениями. На данном этапе Вам предстоит помочь ему разобраться с распределением Хи-квадрат, а именно посмотреть, как соотносятся медиана, мода и математическое ожидание случайных величин с данным распределением.

`@instructions`
* Посчитайте медиану Хи-квадрат распределения с 3 степенями свободы, используя команду `qchisq(p, df)`, где p означает необходимую квантиль распределения, а df - число степеней свободы.
* Посчитайте моду Хи-квадрат распределения с 3 степенями свободы. Для этого необходимо создать функцию плотности распределения f, используя команды `function(x)` и `dchisq(x, df)`. После это максимизируйте данную функцию плотности с помощью команды `optimize` (по умолчанию данная команда минимизирует функцию, поэтому необходимо поставить значение `TRUE` аргумента `maximum`).
* Посчитайте математическое ожидание Хи-квадрат распределения с 3 степенями свободы. Для этого вспомните формулу математического ожидания в непрерывном случае:  ![](https://dl.dropboxusercontent.com/s/t2tjfkb1kxm3yg4/123.png?dl=0),  а также команды `function(x)` и `dchisq(x, df)`, с которыми Вы уже знакомы. Интегрировать функцию поможет команда `integrate(f, lower, upper)`.

`@hint`
Обратите внимание на правильность написания команды `dchisq(x, df)`, где `df` - это число степеней свободы, а также на формулу для расчета математического ожидания.


`@sample_code`
```{r}
#Медиана
med <- q____(_, _)
med

#Мода
f <- function(_) {
  d____(_, _)
}
mode <- optimize(_, c(0, 100), maximum = ____)
mode

#Математическое ожидание
f <- function(_) {
  _*d____(_, _)
}
mu <- integrate(_, _, _)
mu
```
`@solution`
```{r}
#Медиана
qchisq(0.5, 3)

#Мода
f <- function(x) {
  dchisq(x, 3)
}
optimize(f, c(0, 100), maximum = TRUE)

#Математическое ожидание
f <- function(x) {
  x*dchisq(x, 3)
}
mu <- integrate(f, -Inf, Inf)
mu
```
`@sct`
```{r}
#General
#ex() %>% check_object("med") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления медианы с помощью команды `chisq(p, df)`.")
#ex() %>% check_object("mode") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления моды.")
#ex() %>% check_object("f") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления моды.")
#ex() %>% check_object("f") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления математического ожидания.")
#ex() %>% check_object("mu") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления математического ожидания.")

test_error()
success_msg("Замечательно! Как Вы могли убедиться, значения медианы, моды и математического ожидания для распределения Хи-квадрат не совпадают!")
```





---
## Распределение Стьюдента

```yaml
type: NormalExercise

xp: 100

key: 8c2c232912



```

Теперь исследователь Геннадий приступает к работе с распределением Стьюдента. В этом задании Вы сможете рассчитать математическое ожидание и дисперсию для данного распределения, увидеть, как они связаны со степенями свободы, а также научитесь самостоятельно строить график функции плотности распределения Стьюдента с разными степенями свободы.

`@instructions`
* Посчитайте математическое ожидание распределения Стьюдента с 3 степенями свободы. Как и в предыдущем задании Вы можете использовать команды `function` и `integrate`, а также обратите внимание на то, как задается функция плотности для распределения Стьюдента: `dt(x, df)`, где `df` - число степеней свободы.
* С помощью интегрирования посчитайте дисперсию распределения Стьюдента с 3 степенями свободы. Для этого вспомните формулу для нахождения дисперсии, которую Вы использовали в предыдущем блоке: $Var(X) = E(X^2) - (E(X))^2$. Теперь Вы можете сопоставить полученное значение с дисперсии с результатом, вычисленным по формуле $\frac{n}{n-2} $, где n - число степеней свободы.

`@hint`
Обратите внимание на правильность команд `function` для случаев `E(X)` и `E(X2)`, а также  `integarate`.


`@sample_code`
```{r}
#Математическое ожидание E(X)
f <- ____(x) {
  _______
}
mu <- ______(_, _, _)
mu

#Математическое ожидание E(X2)
f <- ____(x) {
  _______
}
mu_2 <- ______(_, _, _, subdivisions = 2000)
mu_2

#Дисперсия
__$value - __$value__
```
`@solution`
```{r}
#Математическое ожидание E(X)
f <- function(x) {
  x*dt(x, 3)
}
mu <- integrate(f, -Inf, Inf)
mu

#Математическое ожидание E(X2)
f <- function(x) {
  x^2*dt(x, 3)
}
mu_2 <- integrate(f, -Inf, Inf, subdivisions = 2000)
mu_2

#Дисперсия
mu_2$value - mu$value^2
```
`@sct`
```{r}
#General
#ex() %>% check_object("f") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления математического ожидания E(X).")
#ex() %>% check_object("mu") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления математического ожидания E(X).")
#ex() %>% check_object("f") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления математического ожидания E(X2).")
#ex() %>% check_object("mu_2") %>% check_equal(incorrect_msg = "Проверьте правильность вычисления математического ожидания E(X2).")
#ex() %>% check_output("3", missing_msg = "Проверьте правильность формулы для расчета дисперсии.")

test_error()
success_msg("Отлично! Теперь Вы убедились, что формула дисперсии, представленная на слайде, справедлива.")
```
