---
  title: "Выборочные характеристики"
  description: В этой главе Вы изучите основные выборочные характеристики, а также посмотрите, каким образом их можно расчитывать и визуализировать в R.
  v2: true




---
## Выборочные характеристики

```yaml
type: VideoExercise
key: 73cb8162a4
lang: r
xp: 50
skills: 1
video_link: https://dl.dropboxusercontent.com/s/ww3s3b6x6fpd5q4/%D0%9D%D0%B0%D1%81%D1%82%D1%8F%2C%20%D0%B2%D0%B8%D0%B4%D0%B5%D0%BE.mp4?dl=0
```


---
## Эмпирическая функция распределения

```yaml
type: NormalExercise

xp: 100

key: ad84388c9f



```

В этой главе мы научимся вычислять основные выборочные характеристики при помощи *R*. Будем работать с датасетом `faithful`, который содержит данные о продолжительности `eruptions`  и времени ожидания `waiting` между извержениями гейзера Старый Служака. Данные уже доступны в рабочем пространстве.


Давайте посмотрим на распределение времени ожидания извержения гейзера. Для этого попробуем самостоятельно построить эмпирическую функцию распределения(от англ. ECDF - Empirical cumulative distribution function). Для начала выполним все необходимые расчеты.

`@instructions`
- Прежде чем делать вычисления, полезно разобраться, что именно и в каких единицах измерения описывают Ваши переменные. Так как мы пользуемся  датасетом из пакета *R*, узнать это можно с помощью команды `?faithful`. Аналогичино, можно получить информацию о других объектах в *R*.
- Посчитатйте число наблюдений (количество строк в матрице `nrow()`).
- Постройте вариационный ряд значений времени ожидания. Вам пригодится функция `sort()`. Полученные значения сохраните в переменную `x_ecdf`.
- Сгенерируйте значения функции распределения и сохраните их в переменную `y_cdf`.

`@hint`
- Отсортируйте значения времени ожидания в порядке возрастания. Затем сгенерируйте значения функции распределения. В данном случае они лежат в интервале $ [ \frac{1}{n} ,1] $.


`@sample_code`
```{r}
#Познакомьтесь с информацией о датасете


#Найдите число наблюдений
n <- nrow(__)

#Постройте вариационный ряд значений времени ожидания
x_ecdf <- sort(___, decreasing = FALSE)

#Сгенерируйте значения выборочной функции распределения
y_ecdf <- seq(from = ___, to = ___, by=___)/n
```
`@solution`
```{r}
#Познакомьтесь с информацией о датасете


#Найдите число наблюдений
n <- nrow(faithful)

#Постройте вариационный ряд значений времени ожидания
x_ecdf <- sort(faithful$waiting, decreasing = FALSE)

#Сгенерируйте значения выборочной функции распределения
y_ecdf <- seq(from = 1, to = n, by=1)/n
```
`@sct`
```{r}
ex() %>% check_object("n") %>% check_equal(incorrect_msg = "Число наблюдений равно числу строк в датасете.")
ex() %>% check_object("x_ecdf") %>% check_equal(incorrect_msg = "Нужно получить отсортированные значения времени ожидания.")
ex() %>% check_object("y_ecdf") %>% check_equal(incorrect_msg = "Какая область определения у функции распределения?")
test_error()
success_msg("Чудесно! Осталось совсем чуть-чуть!")
```


---
## Визуализация

```yaml
type: NormalExercise

xp: 100

key: e617f3a421



```

После того, как Вы подготовили данные, можно заняться их визуализацией. Опять воспользуемся пакетом `ggplot2`. Он уже доступен в Вашем рабочем пространстве. Вам все еще не потребуется особых навыков работы с данным пакетом.  Просто укажите оси и наслаждайтесь!

`@instructions`
-  С помощью функции `ggplot2()` постройте эмпирическую функцию распределения. Все Ваши предыдущие расчеты уже находятся в рабочем пространстве. Вам нужно указать только оси:  `mapping = aes(x=  , y=   )`.

`@hint`
- Значения аргумента и функции Вы посчитали в предыдущем задании: `x_ecdf` и `y_ecdf`.

`@pre_exercise_code`
```{r}
library(ggplot2)
n <- nrow(faithful)

#Постройте вариационный ряд значений времени ожидания
x_ecdf <- sort(faithful$waiting, decreasing = FALSE)

#Сгенерируйте значения выборочной функции распределения
y_ecdf <- seq(from = 1, to = n, by=1)/n
```
`@sample_code`
```{r}
#Постройте выборочную функцию распределения
ggplot(mapping = aes(x = ___, y= ___)) + geom_line() + labs(title = 'ECDF', x = 'Waiting time', y = 'F(x)') +theme(plot.title = element_text(hjust = 0.5))
```
`@solution`
```{r}
library(ggplot2)
ggplot(mapping = aes(x_ecdf, y_ecdf)) + geom_line() + labs(title = 'ECDF', x = 'Waiting time', y = 'F(x)')+theme(plot.title = element_text(hjust = 0.5))
```
`@sct`
```{r}
ex() %>% {
  check_function(., "aes") %>% {
    check_arg(., "x") %>% check_equal(eval = FALSE) 
    check_arg(., "y") %>% check_equal(eval = FALSE)
  	}
  }
test_error()
success_msg("Поздравляю! Вы мастер выборочных функций распределения!")
```



---

## Выборка и расчет выборочных характеристик

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: f3e9bc7cb4



```

Зачастую неизвестно то, как распределены случайные величины, невозможно наблюдать генеральную совокупность, в связи с чем расчет теоретических характеристик распределения ограничен, не всегда доступен для исследователя в реальной жизни. Однако есть определенная выборка, состоящая из ряда наблюдений какой-либо случайной величины, по которой могут быть рассчитаны выборочные характеристики для:

1. оценки параметров распределения,
2. предсказания результата события.

Итак, сейчас вам предстоит найти несмещенную выборочную дисперсию продолжительности извержения гейзера "Старый Служака" двумя способами. Данный датасет уже доступен в рабочем пространстве под названием `faithful`. Для обращения к столбцу датасета используйте `faithful$name_of_column`.

`@instructions`
- Для вычисления средней продолжительности извержения гейзера "Старый Служака" используйте функцию `mean()`.
- Для подсчета количества наблюдений в датасете используйте функцию `nrow()` (переменная `n` в формуле дисперсии).
- Посчитайте несмещенную выборочную дисперсию продолжительности извержения гейзера (`faithful$eruptions`) **по формуле** с использованием функции `sum()`. Полученный результат сохраните в переменную `var_eval` и выведите на экран значение.
- Посчитайте несмещенную выборочную дисперсию продолжительности извержения гейзера (`faithful$eruptions`) **с помощью функции** `var()`. Полученный результат сохраните в переменную `var_erupt` и выведите на экран значение. Сравните полученные результаты.

`@hint`
Для подсчета несмещенной выборочной дисперсии по формуле необходимо `sum((faithful$eruptions - mean(faithful$eruptions)) ^ 2) / (nrow(faithful) - 1)`.

`@pre_exercise_code`
```{r}
library(datasets)
data("faithful")
```
`@sample_code`
```{r}
#Несмещенная выборочная дисперсия продолжительности извержения гейзера по формуле.
var_eval <- 


#Несмещенная выборочная дисперсия продолжительности извержения гейзера с помощью функции.
var_erupt <-

```
`@solution`
```{r}
#Несмещенная выборочная дисперсия продолжительности извержения гейзера по формуле.
var_eval <- sum((faithful$eruptions - mean(faithful$eruptions)) ^ 2) / (nrow(faithful) - 1)
var_eval

#Несмещенная выборочная дисперсия продолжительности извержения гейзера с помощью функции.
var_erupt <- var(faithful$eruptions)
var_erupt
```
`@sct`
```{r}
test_student_typed("var_eval <- sum((faithful$eruptions - mean(faithful$eruptions)) ^ 2) / (nrow(faithful) - 1)", not_typed_msg = "Что-то не так со значением `var_eval`. Использовали ли вы функцию `sum()` для подсчета несмещенной дисперсии по формуле?")

#fourth instruction
test_student_typed("var_erupt <- var(faithful$eruptions)", not_typed_msg = "Что-то не так со значением `var_erupt`.")
test_output_contains("1.302728", times=2)
test_error()
success_msg("Превосходно! Как мы видим, значения оценки дисперсии, полученные различными способами, совпадают.")
```



---
## Ковариационная матрица

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: a458f30712



```

Попробуем посчитать ковариацию и корреляцию между временем ожидания извержения гейзера и его продолжительностью. Функция `cov()` позволяет получить ковариационную матрицу, где элемент матрицы $𝑎_{𝑖,𝑗}$ равен ковариации между *i* и *j* признаками. На главной диагонали расположены дисперсии значений признаков.

`@instructions`
- Постройте ковариацинную матрицу признаков.
- Найдите ковариацию между признаками. Так как их всего два, подойдет любой элемент матрицы, не лежащий на главной диагонали. Обратиться к элементу матрицы можно с помощью квадратных скобок: `matrix[i, j]`.
- По формуле посчитайте корреляцию двух признаков. 
- Проверьте себя с помощью функции cor().

`@hint`
- В качестве аргумента функции ковариации используйте весь датасет, для фукции ковариации - отдельно значения каждого признака.


`@sample_code`
```{r}
#Постройте ковариацинную матрицу признаков 
cov_matrix <- ___

#Посмотрите, как устроена матрица

#Найдите ковариацию между двумя признаками
covar <- ___

#Посчитатйте корреляцию времению ожидания и числа извержений
cor <- ___
```
`@solution`
```{r}
#Постройте ковариацинную матрицу признаков 
cov_matrix <-cov(faithful)
#Посмотрите, как устроена матрица 
#Найдите ковариацию между двумя признаками
covar <- cov_matrix[2,1]
#Посчитатйте корреляцию времению ожидания и числа извержений
cor <- cor(faithful$eruptions, faithful$waiting)
```
`@sct`
```{r}
ex() %>% check_object("cov_matrix") %>% check_equal(incorrect_msg = "Убедитесь, что Вы передали функции верный аргумент.")
ex() %>% check_object("covar") %>% check_equal(incorrect_msg = "Вам нужны элементы матрицы, не лежащие на диагонали.")
ex() %>% check_object("cor") %>% check_equal(incorrect_msg = "В качестве аргументов передайте функции два вектора со значениями признаков.")
            
test_error()
success_msg("Да Вы и правда молодец!")
```




---
## Оценка параметров случайных величин

```yaml
type: VideoExercise
key: d28266493f
lang: r
xp: 50
skills: 1
video_link: https://dl.dropboxusercontent.com/s/wrfiyf91h6leg29/%D0%9D%D0%B0%D0%B4%D1%8F%2C%20%D0%B2%D0%B8%D0%B4%D0%B5%D0%BE.mp4?dl=0
```


---
## Метод моментов

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: a4abd8dbe7



```

**Метод моментов**: теоретические и выборочные моменты совпадают в точке оценки неизвестного параметра.

Оценим среднее время ожидания между извержениями гейзера методом моментов, используя первый начальный момент. Датасет про гейзер "Старый Служака" уже доступен в рабочем пространстве под названием `faithful`.

`@instructions`
- Оцените среднее время ожидания между извержениями гейзера (`faithful$waiting`) методом моментов, используя первый начальный момент.
- Сохраните полученный результат в переменную `mean_time` и выведите ее значение на экран.

`@hint`
Первый начальный момент – это *математическое ожидание* случайной величины, первый выборочный начальный момент – *выборочное среднее*.

`@pre_exercise_code`
```{r}
library(datasets)
data("faithful")
```
`@sample_code`
```{r}
#Оценка среднего времени ожидания между извержениями гейзера с использованием первого начального момента.
mean_time <- 

#Выведите на экран получившееся значение.

```
`@solution`
```{r}
#Оценка среднего времени ожидания между извержениями гейзера с использованием первого начального момента.
mean_time <- mean(faithful$waiting)

#Выведите на экран получившееся значение.
mean_time
```
`@sct`
```{r}
#first instruction
test_function("mean", incorrect_msg = "Что-то не так с `mean_time`. Вызывали ли вы функцию `mean()` для подсчета среднего?")

#second instruction
test_student_typed("mean_time <- mean(faithful$waiting)", not_typed_msg = "Что-то не так с `mean_time`.")

#third instruction
test_output_contains("mean_time", incorrect_msg = "Вывели ли вы получившееся значение на экран?")

#General
test_error()
success_msg("Замечательно! Теперь мы знаем, что среднее время ожидания между извержениями гейзера примерно 71 минута!")
```

---
## Метод максимального правдоподобия

```yaml
type: PureMultipleChoiceExercise

xp: 50
skills: 1
key: 0ef3cf6ecf



```

Что необходимо знать для того, чтобы оценить параметры методом максимального правдоподобия (ММП)?


`@hint`
Функция плотности может быть получена из функции распределения случайных величин.





`@possible_answers`
- Выборочное среднее; 
- [Функцию распределения случайных величин;] 
- Оценку параметра методом моментов; 
- Стандартное отклонение.

`@feedbacks`
- Попробуйте еще раз.
- Отлично! Действительно, для применения ММП необходимо максимизировать функцию правдоподобия, для нахождения которой нужно знать, как случайные величины распределены.
- Попробуйте еще раз.
- Попробуйте еще раз.




---
## Вычисление квантилей

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: dc4fa381af



```

Для того, чтобы посчитать квантили с использованием R, сначала необходимо сгенерировать данные, например из нормального распределения с помощью функции `rnorm()`:

`normal <- rnorm(n, mean, sd)`, где **n** – количество генерируемых наблюдений, **mean** – математическое ожидание, **sd** – стандартное отклонение.

Затем необходимо применить функцию `quantile(normal, p)`, где **p** – порядок (уровень) квантиля.

**Напоминание**: нормальное распределение с нулевым математическим ожиданием (mean = 0) и единичной дисперсией (var = 1) – стандартное нормальное распределение.
Площадь под графиком функции плотности - вероятность.

`@instructions`
- Сгенерируйте миллион наблюдений из стандартного нормального распределения и сохраните результат в переменную `normal`.
- Посчитайте третий квартиль (0.75-квантиль) с помощью функции `quantile()` для данного распределения.
- Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль).

`@hint`
Правильно ли вы посчитали третий квартиль `quantile(normal, 0.75)`?

`@pre_exercise_code`
```{r}
library(ggplot2)
```
`@sample_code`
```{r}
#Сгенерируйте миллион наблюдений из стандартного нормального распределения.
normal <- 

#Посчитайте третий квартиль (0.75-квантиль) для данного распределения.
quartile <- 

#Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль).
ggplot() + 
  geom_density(aes(normal), fill = "blue", alpha = 0.1) +
  geom_vline(xintercept = quartile, col = "red", size = 1.5)
```
`@solution`
```{r}
#Сгенерируйте миллион наблюдений из стандартного нормального распределения.
normal <- rnorm(1000000, 0, 1)

#Посчитайте третий квартиль (0.75-квантиль) для данного распределения.
quartile <- quantile(normal, 0.75)

#Изобразите функцию плотности данного распределения и третий квартиль (0.75-квантиль).
ggplot() + 
  geom_density(aes(normal), fill = "blue", alpha = 0.1) +
  geom_vline(xintercept = quartile, col = "red", size = 1.5)
```
`@sct`
```{r}
#second instruction
test_student_typed("normal <- rnorm(1000000, 0, 1)")
test_student_typed("quartile <- quantile(normal, 0.75)", not_typed_msg = "Посчитали третий квартиль?")

#General
test_error()
success_msg("Круто! 0.75-квантиль - красная линия на графике, левее которой площадь под графиком функции плотности равна 0.75.")
```





---
## Какой квантиль больше?

```yaml
type: MultipleChoiceExercise
lang: r
xp: 50
skills: 1
key: 6c5bb1e1b1



```

Определите, квантиль какого уровня больше для нормального распределения: 0.05 или 0.1? Почему? Нормальное распределение сгенерировано и доступно в рабочем пространстве под названием `normal`.

`@instructions`
- Квантиль уровня 0.05 больше, чем квантиль уровня 0.1; 
- [Квантиль уровня 0.1 больше, чем квантиль уровня 0.05;] 
- Квантили уровней 0.05 и 0.1 равны.

`@hint`
Чтобы сравнить квантили уровней p1 и p2, используйте следующее выражение: quantile(normal, p1) > quantile(normal, p2)

`@pre_exercise_code`
```{r}
normal <- rnorm(1000000, 0, 1)
```


`@sct`
```{r}
msg1 = "Попробуйте еще раз. Для вычисления квантилей уровня p, используйте функцию quantile(normal, p)."
msg2 = "Превосходно! Квантиль уровня 0.1 больше для нормального распределения, потому что мы с большей вероятностью попадем левее какого-либо числа (площадь под графиком функции плотности будет больше), если число, квантиль p-ого порядка, будет правее, то есть больше."
msg3 = "Попробуйте еще раз. Для вычисления квантилей уровня p, используйте функцию quantile(normal, p)."
test_mc(2, feedback_msgs = c(msg1, msg2, msg3))
```

---
## Интерпретация доверительных интервалов

```yaml
type: PureMultipleChoiceExercise

xp: 50
skills: 1
key: e692d3bd0c



```

Выберите верное суждение о двустороннем 99% доверительном интервале.







`@possible_answers`
- Построив 99 % доверительный интервал, мы получаем интервал, в котором лежит 99 % наших наблюдений.
- С вероятностью 99% неизвестный параметр  принимает значения из полученного доверительного интервала.
- [Проведя эксперимент большое число раз, мы ожидаем, что в 1% экспериментов доверительный интервал не будет накрывать истинное значение параметра.]
- Вероятность, что неизвестный параметр принимает значение больше верхней границы доверительного интервала, равна 1%.

`@feedbacks`
- В общем случае, для каждой конкретной выборки в границы доверительного интервала может попасть различное число наблюдений. Вам важно оценить, как часто в эти границы попадает неизвестный параметр.
- Неизвестный параметр, который вы пытаетесь оценить, принимает одно единственное значение.
- Замечательно! Вы верно поняли смысл доверительного интервала. Теперь самое время построить его!
- Мы строим двусторонний доверительный интервал!




---
## Доверительный интервал для математического ожидания

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: c7f8739f05



```

В этом задании мы построим 95 % доверительный интервал для среднего времени ожидания извержения гейзера. Так как мы имеем большое число наблюдений, можем воспользоваться универсальной формулой для математического ожидания. Большую часть работы Вы уже выполнили в предыдущих заданиях, поэтому здесь Вам останется только собрать все воедино. 

**Note:** В *R* существует несколько простых и удобных команд, которые облегчают работу с нормальным распределением:
- `rnorm(n, mean, sd)` - генерирует n нормально распределенных случайных величин.
- `qnorm(p, mean, sd)` - квантиль порядка p.
- `pnorm(q, mean, sd)` - вероятность, что случайная величина примет значение, меньше q.
- `dnorm(x, mead, sd)` - значение функции плотности в точке x.

`@instructions`
- Найдите критическое значение статистики с помощью `qnorm()`. 
- Посчитатйе границы доверительного интервала. Сохраните полученные значения в переменные `low` и `high`.

`@hint`
- При уровне значимости $\alpha$ критические значения  соответствуют квантилям порядка
$\frac{\alpha}{2}$ и $\left(1-\frac{\alpha}{2}\right)$. В силу симметричности функции плотности стандартного нормального распределения эти значения равны по модулю.


`@sample_code`
```{r}
#Посчитайте среднее время ожидания извержения гейзера
mu_hat <- faithful$waiting

#Найдите критическое значение статистики
z_critic <- ___

#Посчитайте границы доверительного интервала. 
low <- ___

high <- ___
```
`@solution`
```{r}
#Посчитайте среднее время ожидания извержения гейзера
mu_hat<- faithful$waiting

#Найдите критическое значение статистики
z_critic <-qnorm(0.975)

#Посчитайте  границы доверительного интервала
low<- mu_hat - z_critic*sd(faithful$waiting)/sqrt(nrow(faithful))

high<- mu_hat + z_critic*sd(faithful$waiting)/sqrt(nrow(faithful))
```
`@sct`
```{r}
msg_1 = "Не забывайте, что интервал двустороний."
msg_2 = "Кажется, Вы забыли формулу доверительного интервала."


test_object("z_critic", undefined_msg = msg_1, incorrect_msg = msg_1)
test_object("low", undefined_msg = msg_2, incorrect_msg = msg_2)
test_object("high", undefined_msg = msg_2, incorrect_msg = msg_2)
test_error()
success_msg("Вот это да! Вы осилили свой первый доверительный интервал. Двигаемся дальше!")
```










---
## Доверительный интервал для дисперсии

```yaml
type: NormalExercise

xp: 100

key: ec782fd88d



```

В заключительном задании главы "Выборочные характеристики" мы построим доверительный интервал для дисперсии времени ожидания извержения гейзера. При построении интервала не забывайте, что $\chi^2$ - распределение не симметрично, в отличие от сандартного нормального. Поэтому придется отдельно найти все два критических значенияю

`@instructions`
- Найдите число степеней свободы. 

**Hint:** Длину вектора можно вычислить с помощью функции `length`.
- Посчитайте критические значения. Вам пригодится функция qchisq().
- Посчитайте верхнюю и нижнюю границы доверительного интервала.

`@hint`
- Количество наблюдений можно узнать с помощью функции `length()`. При уровне значимости $\alpha$ критические значения  соответствуют квантилям порядка $\frac{\alpha}{2}$ и $\left(1-\frac{\alpha}{2}\right)$.


`@sample_code`
```{r}
#Посчитайте число степеней свободы
df <- ___

#Найдите критические значения
сrit_low <- ___
crit_high <- ___ 

#Вычислите границы 90% доверительного интервала
high <- ___
low  <- ___
```
`@solution`
```{r}
#Посчитайте число степеней свободы

df <- length(faithful$eruptions) - 1

#Вычислите границы 90% доверительного интервала
crit_low <- qchisq(0.95, df)
crit_high <- qchisq(0.05, df)
high  <- df*var(faithful$eruptions)/crit_low
low   <- df*var(faithful$eruptions)/crit_high
```
`@sct`
```{r}
msg_1 = "Число степений свободы должно быть на единицу меньше числа наблюдений."
msg_2 = "Кажется, Вы забыли формулу доверительного интервала."
msg_3 = "Чтобы получить критические значения, передайте в функцию qchisq() порядок квантиля и число степеней свободы."


test_object("df", undefined_msg = msg_1, incorrect_msg = msg_1)
test_object("crit_high", undefined_msg = msg_3, incorrect_msg = msg_3)
test_object("crit_low", undefined_msg = msg_3, incorrect_msg = msg_3)
test_object("low", undefined_msg = msg_2, incorrect_msg = msg_2)
test_object("high", undefined_msg = msg_2, incorrect_msg = msg_2)
test_error()
success_msg("Вот это да! Вы осилили свой первый доверительный интервал. Двигаемся дальше!")
```








